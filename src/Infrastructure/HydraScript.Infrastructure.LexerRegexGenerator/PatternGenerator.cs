using System.Collections.Immutable;
using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace HydraScript.Infrastructure.LexerRegexGenerator;

[Generator]
public partial class PatternGenerator : IIncrementalGenerator
{
    private const string AttributeSourceCode = @"// <auto-generated/>

namespace HydraScript.Infrastructure;

[System.AttributeUsage(System.AttributeTargets.Class)]
public class PatternContainerAttribute<T>(string json) : System.Attribute
    where T : HydraScript.Domain.FrontEnd.Lexer.IGeneratedRegexContainer
{
    public string Json { get; } = json;
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "PatternContainerAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "HydraScript.Infrastructure.PatternContainerAttribute`1",
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetTypeDeclarationForSourceGen(ctx))
            .Where(static x => x is not null)
            .Select(static (x, _) => x!);

        context.RegisterImplementationSourceOutput(provider.Collect(), GenerateCode);
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node) =>
        node is ClassDeclarationSyntax candidate &&
        candidate.Modifiers.Any(SyntaxKind.PartialKeyword) &&
        candidate.Modifiers.Any(SyntaxKind.InternalKeyword);

    private static RegexContainerInfo? GetTypeDeclarationForSourceGen(
        GeneratorAttributeSyntaxContext context)
    {
        var attribute = context.Attributes.FirstOrDefault();
        if (attribute is null)
            return null;
        var visitable = (ClassDeclarationSyntax)context.TargetNode;
        var json = attribute.ConstructorArguments.First().Value!.ToString()!;
        return new RegexContainerInfo(
            ClassName: visitable.Identifier.Text,
            json);
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<RegexContainerInfo> containerInfos)
    {
        foreach (var info in containerInfos)
        {
            var tokenTypes = JsonSerializer.Deserialize(
                    info.Json,
                    PatternGeneratorContext.Default.IEnumerableTokenType)!
                .OrderBy(x => x.Priority)
                .Concat([new TokenType("ERROR", @"\S+", int.MaxValue)]);
            var pattern = string.Join('|', tokenTypes.Select(t => t.GetNamedRegex()));

            var code = $@"// <auto-generated/>

using System.Diagnostics.CodeAnalysis;

namespace HydraScript.Infrastructure;

internal partial class {info.ClassName}
{{
    [StringSyntax(StringSyntaxAttribute.Regex)]
    public const string Pattern =
        """"""
            {pattern}
        """""";
}}
";
            context.AddSource($"{info.ClassName}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private record RegexContainerInfo(
        string ClassName,
        string Json);
}