using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using NSubstitute;
using Xunit;

namespace HydraScript.Infrastructure.LexerRegexGenerator.UnitTests;

public class PatternGeneratorTests
{
    [StringSyntax(StringSyntaxAttribute.Json)]
    private const string JsonStringReplacement =
        """
        [
            {
                "tag": "Test2",
                "pattern": "test2",
                "priority": 2
            },
            {
                "tag": "Test1",
                "pattern": "test1",
                "priority": 1
            }
        ]
        """;

    [Fact]
    public void Initialize_PatternContainerMarked_CorrectlyGenerated()
    {
        var provider = Substitute.For<ITokenTypesJsonStringProvider>();
        provider.TokenTypesJsonString.Returns(JsonStringReplacement);
        var generator = new PatternGenerator
        {
            Provider = provider
        };
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        driver = driver.RunGeneratorsAndUpdateCompilation(CreateCompilation(string.Empty), out var outputCompilation,
            out var diagnostics);
        Debug.Assert(diagnostics.IsEmpty);
        Debug.Assert(outputCompilation.SyntaxTrees.Count() == 2);

        var runResult = driver.GetRunResult();

        var generatedFileSyntax = runResult.GeneratedTrees
            .Single(t => t.FilePath.EndsWith("PatternContainer.g.cs"));

        const string expectedSource = 
""""
// <auto-generated/>

using System.Diagnostics.CodeAnalysis;

namespace HydraScript.Infrastructure;

internal partial class PatternContainer
{
    [StringSyntax(StringSyntaxAttribute.Regex)]
    public const string Value = """(?<Test1>test1)|(?<Test2>test2)|(?<ERROR>\S+)""";
}

"""";

        Assert.Equal(
            expectedSource,
            generatedFileSyntax.GetText().ToString(),
            ignoreLineEndingDifferences: true);
    }

    private static CSharpCompilation CreateCompilation(string source) =>
        CSharpCompilation.Create("compilation",
            new[] { CSharpSyntaxTree.ParseText(source) },
            new[] { MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location) },
            new CSharpCompilationOptions(OutputKind.ConsoleApplication));
}